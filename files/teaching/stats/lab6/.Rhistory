#Removing previous datasets in memory
rm(list = ls())
#Loading the relevant libraries
library(ggplot2)
library(gridExtra)
library(dplyr)
library(purrr)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggrepel)
library(modelsummary)
library(broom)
library(gganimate)
#Setting path
setwd("/Users/bgpopescu/Dropbox/john_cabot/teaching/stats/lab8/")
#Step1: Loading the data
life_expectancy <- read.csv(file = './life-expectancy.csv')
urbanization <- read.csv(file = './share-of-population-urban.csv')
#Step1: Calculating the mean
life_expectancy2<-life_expectancy%>%
group_by(Code, Entity)%>%
summarize(life_expectancy=mean(Life.expectancy.at.birth..historical., na.rm=T))
#Step2: Cleaning the Data
life_expectancy3<-subset(life_expectancy2, life_expectancy2$Code!="")
#Step1: Calculating the mean
urbanization2<-urbanization%>%
group_by(Code, Entity)%>%
summarize(urbanization=mean(Urban.population....of.total.population., na.rm=T))
#Step2: Cleaning the Data
urbanization3<-subset(urbanization2, urbanization2$Code!="")
urbanization3<-subset(urbanization3, select = -c(Entity))
#Step1: Performing the left_merge
merged<-left_join(life_expectancy3, urbanization3, by = c("Code" = "Code"))
#Step2: Getting rid of the NAs
merged<-na.omit(merged)
#Step3: Sorting by Entity name
# sort by mpg
merged <- merged[order(merged$Entity),]
glimpse(merged)
cor_coeff<-cor(merged$life_expectancy,  merged$urbanization, method = c("pearson"))
cor_coeff
b_res<-cor_coeff*(sd(merged$life_expectancy)/sd(merged$urbanization))
b_res
model<-lm(life_expectancy~urbanization, data=merged)
summary(model)
model<-lm(life_expectancy~urbanization, data=merged)
models<-list("Life Expectancy" = model)
cm <- c('urbanization'='Urbanization',
"(Intercept)"="Intercept")
modelsummary(models, stars = TRUE, coef_map = cm, gof_map = c("nobs", "r.squared"))
results <- tidy(model)
results
View(results)
#To calculate the confidence interval, we use 1.96, meaning that 95% of the area under a normal curve lies within approximately 1.96 standard deviations of the mean
ggplot(results,
aes(x = estimate, y = term)) +
geom_point(aes(x = estimate,
y = term))+
geom_errorbar(aes(xmin = estimate-1.96*std.error, xmax = estimate+1.96*std.error),
size = 1, width=0)
#Removing previous datasets in memory
rm(list = ls())
#Loading the relevant libraries
library(ggplot2)
library(gridExtra)
library(dplyr)
library(purrr)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(ggrepel)
library(modelsummary)
library(broom)
library(gganimate)
#Setting path
setwd("/Users/bgpopescu/Dropbox/john_cabot/teaching/stats/lab8/")
#Step1: Loading the data
life_expectancy <- read.csv(file = './life-expectancy.csv')
urbanization <- read.csv(file = './share-of-population-urban.csv')
#Step1: Calculating the mean
life_expectancy2<-life_expectancy%>%
group_by(Code, Entity)%>%
summarize(life_expectancy=mean(Life.expectancy.at.birth..historical., na.rm=T))
#Step2: Cleaning the Data
life_expectancy3<-subset(life_expectancy2, life_expectancy2$Code!="")
#Step1: Calculating the mean
urbanization2<-urbanization%>%
group_by(Code, Entity)%>%
summarize(urbanization=mean(Urban.population....of.total.population., na.rm=T))
#Step2: Cleaning the Data
urbanization3<-subset(urbanization2, urbanization2$Code!="")
urbanization3<-subset(urbanization3, select = -c(Entity))
#Step1: Performing the left_merge
merged<-left_join(life_expectancy3, urbanization3, by = c("Code" = "Code"))
#Step2: Getting rid of the NAs
merged<-na.omit(merged)
#Step3: Sorting by Entity name
# sort by mpg
merged <- merged[order(merged$Entity),]
glimpse(merged)
cor_coeff<-cor(merged$life_expectancy,  merged$urbanization, method = c("pearson"))
cor_coeff
b_res<-cor_coeff*(sd(merged$life_expectancy)/sd(merged$urbanization))
b_res
model<-lm(life_expectancy~urbanization, data=merged)
summary(model)
model<-lm(life_expectancy~urbanization, data=merged)
models<-list("Life Expectancy" = model)
cm <- c('urbanization'='Urbanization',
"(Intercept)"="Intercept")
modelsummary(models, stars = TRUE, coef_map = cm, gof_map = c("nobs", "r.squared"))
results <- tidy(model)
results
#To calculate the confidence interval, we use 1.96, meaning that 95% of the area under a normal curve lies within approximately 1.96 standard deviations of the mean
ggplot(results,
aes(x = estimate, y = term)) +
geom_point(aes(x = estimate,
y = term))+
geom_errorbar(aes(xmin = estimate-1.96*std.error, xmax = estimate+1.96*std.error),
size = 1, width=0)
model_scaled<-lm(scale(life_expectancy)~scale(urbanization), data=merged)
summary(model_scaled)
model1<-lm(life_expectancy~urbanization, data=merged)
model2<-lm(scale(life_expectancy)~scale(urbanization), data=merged)
models<-list("Unscaled" = model1,
"Scaled" = model2)
cm <- c('urbanization'='Urbanization',
'scale(urbanization)' = 'Urbanization',
"(Intercept)"="Intercept")
modelsummary(models, stars = TRUE, coef_map = cm, gof_map = c("nobs", "r.squared"))
#Step1: Save the lm results to a dataframe
model2<-lm(scale(life_expectancy)~scale(urbanization), data=merged)
results<-tidy(model2)
#Step2: Plot the results
ggplot(results,
aes(x = estimate, y = term)) +
geom_point(aes(x = estimate,
y = term))+
geom_errorbar(aes(xmin = estimate-1.96*std.error, xmax = estimate+1.96*std.error),
size = 1, width=0)
head(merged, n=10)
merged$b<-model1$coefficients["urbanization"]
merged$a<-model1$coefficients[1]
head(merged, n=10)
merged$y_hat<-merged$b*merged$urbanization + merged$a
head(merged, n=10)
sample1<-subset(merged, select = c(Code, life_expectancy, urbanization))
sample1$type<-"Observed"
head(sample1, n=5)
View(sample1)
sample2<-subset(merged, select = c(Code, y_hat, urbanization))
sample2$type<-"Predicted"
names(sample2)[names(sample2)=="y_hat"]<-"life_expectancy"
head(sample2, n=5)
View(sample2)
sample2<-subset(merged, select = c(Code, y_hat, urbanization))
sample2$type<-"Predicted"
sample2<-subset(merged, select = c(Code, y_hat, urbanization))
sample2$type<-"Predicted"
names(sample2)[names(sample2)=="y_hat"]<-"life_expectancy"
head(sample2, n=5)
sample_both<-rbind(sample1, sample2)
# sort by Code
sample_both <- sample_both[order(sample_both$Code),]
head(sample_both)
sample_both<-rbind(sample1, sample2)
# sort by Code
sample_both <- sample_both[order(sample_both$Code),]
head(sample_both)
